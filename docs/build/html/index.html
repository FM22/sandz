<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Documentation for SANDZ &mdash; Spectral Analysis for Nonuniform Complex Data 0.1 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="#" class="icon icon-home"> Spectral Analysis for Nonuniform Complex Data
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">Documentation for SANDZ</a></li>
<li><a class="reference internal" href="#requirements">Requirements</a></li>
<li><a class="reference internal" href="#example-usage">Example usage</a><ul>
<li><a class="reference internal" href="#further-examples">Further Examples</a></li>
</ul>
</li>
<li><a class="reference internal" href="#common-issues">Common Issues</a></li>
<li><a class="reference internal" href="#overview-of-mathematical-concepts">Overview of Mathematical Concepts</a><ul>
<li><a class="reference internal" href="#the-dft">The DFT</a></li>
<li><a class="reference internal" href="#the-ndft">The NDFT</a></li>
<li><a class="reference internal" href="#power-spectral-density">Power Spectral Density</a></li>
<li><a class="reference internal" href="#autocorrelation">Autocorrelation</a></li>
<li><a class="reference internal" href="#arma-process">ARMA Process</a></li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-ndft">Methods</a></li>
<li><a class="reference internal" href="#indices">Indices</a></li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">Spectral Analysis for Nonuniform Complex Data</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="#" class="icon icon-home"></a> &raquo;</li>
      <li>Documentation for SANDZ</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/index.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="documentation-for-sandz">
<h1>Documentation for SANDZ<a class="headerlink" href="#documentation-for-sandz" title="Permalink to this headline"></a></h1>
<p>Last modified: Oct 18, 2021</p>
<p>This is a library for performing spectral analysis on nonuniformly-sampled data using the nonuniform discrete Fourier transform (NDFT).</p>
</section>
<section id="requirements">
<h1>Requirements<a class="headerlink" href="#requirements" title="Permalink to this headline"></a></h1>
<ul class="simple">
<li><p>NumPy and SciPy are required.</p></li>
<li><p>One of pynfft or nfft is recommended (alternatively, a custom NFFT implementation can be used).</p></li>
<li><p>SymPy is required for <a class="reference internal" href="#arma.acf_exact" title="arma.acf_exact"><code class="xref py py-meth docutils literal notranslate"><span class="pre">arma.acf_exact()</span></code></a>.</p></li>
<li><p>Pyplot is required for <a class="reference internal" href="#util.plot_sampled_data" title="util.plot_sampled_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">util.plot_sampled_data()</span></code></a>.</p></li>
</ul>
</section>
<section id="example-usage">
<h1>Example usage<a class="headerlink" href="#example-usage" title="Permalink to this headline"></a></h1>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">ndft</span>
<span class="kn">import</span> <span class="nn">arma</span>
<span class="kn">import</span> <span class="nn">util</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="n">length</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span>
    <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">length</span><span class="p">),</span> <span class="n">length</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">length</span><span class="p">)[</span><span class="n">inds</span><span class="p">]</span>
<span class="n">arma_params</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">2.7607</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.8106</span><span class="p">,</span> <span class="mf">2.6535</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.9238</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">full_data</span> <span class="o">=</span> <span class="n">arma</span><span class="o">.</span><span class="n">arma</span><span class="p">(</span><span class="o">*</span><span class="n">arma_params</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">full_data</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span>

<span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">psd</span><span class="p">)</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">psd_with_freqs</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">,</span> <span class="n">ndft_fun</span><span class="o">=</span><span class="n">ndft</span><span class="o">.</span><span class="n">exe_ndft_fft</span><span class="p">)</span>
<span class="p">(</span><span class="n">lags</span><span class="p">,</span> <span class="n">acf</span><span class="p">)</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">acf_with_lags</span><span class="p">(</span>
    <span class="n">psd</span><span class="o">=</span><span class="n">psd</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">,</span> <span class="n">ndft_fun</span><span class="o">=</span><span class="n">ndft</span><span class="o">.</span><span class="n">exe_ndft_fft</span><span class="p">)</span>

<span class="n">true_psd</span> <span class="o">=</span> <span class="n">arma</span><span class="o">.</span><span class="n">psd_exact</span><span class="p">(</span><span class="o">*</span><span class="n">arma_params</span><span class="p">,</span> <span class="n">freqs</span><span class="p">)</span>
<span class="n">true_acf</span> <span class="o">=</span> <span class="n">arma</span><span class="o">.</span><span class="n">acf_exact</span><span class="p">(</span><span class="o">*</span><span class="n">arma_params</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">lags</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="n">psd_pwr</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">to_db</span><span class="p">(</span><span class="n">psd</span><span class="p">)</span>
<span class="n">true_psd_pwr</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">to_db</span><span class="p">(</span><span class="n">true_psd</span><span class="p">)</span>
</pre></div>
</div>
<p>This code estimates the PSD and ACF of a time series generated by the example ARMA model on p.35 of <em>Spectral Analysis of Univariate Time Series</em> (Percival, Walden), with half of entries removed at random. The estimates can be displayed using the following code, which requires pyplot:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">psd_pwr</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Estimated PSD&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">true_psd_pwr</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;True PSD&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">.8</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Frequency&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;PSD (dB)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xlim</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lags</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">acf</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Estimated ACF&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lags</span><span class="p">,</span> <span class="n">true_acf</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;True ACF&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">.8</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Lag&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Normalised</span><span class="se">\n</span><span class="s2"> autocorrelation&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">ylim</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">1.2</span><span class="p">,</span><span class="mf">1.2</span><span class="p">])</span>
<span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>This gives the plots:</p>
<a class="reference internal image-reference" href="_images/psd_example.png"><img alt="Example plot of PSD" src="_images/psd_example.png" style="width: 600px;" /></a>
<a class="reference internal image-reference" href="_images/acf_example.png"><img alt="Example plot of ACF" src="_images/acf_example.png" style="width: 600px;" /></a>
<section id="further-examples">
<h2>Further Examples<a class="headerlink" href="#further-examples" title="Permalink to this headline"></a></h2>
<p>Here are some further examples. The first two again require pyplot to display the outputs. All of these examples can also be found in <code class="docutils literal notranslate"><span class="pre">examples.py</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">ndft</span>
<span class="kn">import</span> <span class="nn">arma</span>
<span class="kn">import</span> <span class="nn">util</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="n">iterations</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">gen_len</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">arma_params</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">2.7607</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.8106</span><span class="p">,</span> <span class="mf">2.6535</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.9238</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">.9</span><span class="n">j</span><span class="p">,</span> <span class="mf">1.1</span><span class="n">j</span><span class="p">]),</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">dropout_pattern</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]</span>
<span class="n">dropout_pattern</span> <span class="o">*=</span>  <span class="n">gen_len</span><span class="o">//</span><span class="nb">len</span><span class="p">(</span><span class="n">dropout_pattern</span><span class="p">)</span>
<span class="n">full_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">gen_len</span><span class="p">)</span>
<span class="n">times_vec</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">full_times</span><span class="p">,</span> <span class="n">full_times</span><span class="p">[</span><span class="n">dropout_pattern</span><span class="p">],</span> <span class="n">full_times</span><span class="p">[</span><span class="n">dropout_pattern</span><span class="p">]]</span>
<span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;No missing data&quot;</span><span class="p">,</span> <span class="s2">&quot;Periodic gaps&quot;</span><span class="p">,</span> <span class="s2">&quot;Periodic gaps (deconvolved)&quot;</span><span class="p">]</span>

<span class="n">psd</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">times_vec</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">times</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">times_vec</span><span class="p">):</span>
    <span class="n">psd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">iterations</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iterations</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">arma</span><span class="o">.</span><span class="n">arma</span><span class="p">(</span>
            <span class="o">*</span><span class="n">arma_params</span><span class="p">,</span> <span class="n">gen_len</span><span class="p">,</span>
            <span class="n">seed</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">16</span><span class="p">))[</span><span class="n">times_vec</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">psd</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">ndft</span><span class="o">.</span><span class="n">calc_deconvolved_psd</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="n">times_vec</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">psd</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">ndft</span><span class="o">.</span><span class="n">calc_psd</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="n">times_vec</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

<span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">()</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">times_vec</span><span class="p">)):</span>
    <span class="n">util</span><span class="o">.</span><span class="n">plot_sampled_data</span><span class="p">(</span>
        <span class="n">util</span><span class="o">.</span><span class="n">unif_pts</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">psd</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">psd</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">ax</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">db</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">symmetric</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">freqs</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">unif_pts</span><span class="p">(</span><span class="n">gen_len</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
    <span class="n">freqs</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">to_db</span><span class="p">(</span><span class="n">arma</span><span class="o">.</span><span class="n">psd_exact</span><span class="p">(</span><span class="o">*</span><span class="n">arma_params</span><span class="p">,</span> <span class="n">freqs</span><span class="p">)),</span>
    <span class="n">label</span><span class="o">=</span><span class="s2">&quot;True value&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xlim</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">ylim</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">])</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;lower right&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Frequency&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;PSD (dB)&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/deconv_example.png"><img alt="Example of PSD deconvolution" src="_images/deconv_example.png" style="width: 600px;" /></a>
<p>This example shows how spectral estimation of data with periodic gaps can be improved using deconvolution. Note also the lack of aliasing (symmetry) until <em>twice</em> the Nyquist frequency, which is <span class="math notranslate nohighlight">\(0.5\)</span> – this only occurs when the signal is complex.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">ndft</span>
<span class="kn">import</span> <span class="nn">util</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="n">length</span> <span class="o">=</span> <span class="mi">33333</span>
<span class="n">mask</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>
<span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">length</span><span class="p">)[</span><span class="n">mask</span> <span class="o">*</span> <span class="p">(</span><span class="n">length</span><span class="o">//</span><span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">))]</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mf">.3</span><span class="o">*</span><span class="n">times</span><span class="p">)</span> <span class="o">+</span>\
    <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mf">.4</span><span class="o">*</span><span class="n">times</span><span class="p">)</span> <span class="o">+</span>\
    <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mf">.8</span><span class="o">*</span><span class="n">times</span><span class="p">)</span> <span class="o">+</span>\
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)))</span><span class="o">*</span><span class="mf">0.01</span>

<span class="n">acfs</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="mi">4</span>
<span class="n">labels</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;Approximate NuFFT&quot;</span><span class="p">,</span> <span class="s2">&quot;Embedded in FFT&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Periodic NFFT&quot;</span><span class="p">,</span> <span class="s2">&quot;Direct estimation&quot;</span><span class="p">]</span>
<span class="n">util</span><span class="o">.</span><span class="n">benchmark</span><span class="p">()</span>
<span class="n">acfs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">ndft</span><span class="o">.</span><span class="n">calc_acf</span><span class="p">(</span>
    <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">,</span> <span class="n">ndft_fun</span><span class="o">=</span><span class="n">ndft</span><span class="o">.</span><span class="n">exe_nfft_py</span><span class="p">))</span>
<span class="n">util</span><span class="o">.</span><span class="n">benchmark</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">acfs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">ndft</span><span class="o">.</span><span class="n">calc_acf</span><span class="p">(</span>
    <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">,</span> <span class="n">ndft_fun</span><span class="o">=</span><span class="n">ndft</span><span class="o">.</span><span class="n">exe_ndft_fft</span><span class="p">))</span>
<span class="n">util</span><span class="o">.</span><span class="n">benchmark</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">acfs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">ndft</span><span class="o">.</span><span class="n">calc_acf</span><span class="p">(</span>
    <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">ndft_fun</span><span class="o">=</span><span class="n">ndft</span><span class="o">.</span><span class="n">exe_nfft_per</span><span class="p">))</span>
<span class="n">util</span><span class="o">.</span><span class="n">benchmark</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="n">acfs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">util</span><span class="o">.</span><span class="n">direct_acf</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">ndft</span><span class="o">.</span><span class="n">MAX_LAG</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
<span class="n">util</span><span class="o">.</span><span class="n">benchmark</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">acf</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">acfs</span><span class="p">):</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ndft</span><span class="o">.</span><span class="n">MAX_LAG</span><span class="p">),</span> <span class="n">acf</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;lower right&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>This example demonstrates the difference in speed and output of the various NDFT implementations. On my machine, the output to the terminal was:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Approximate</span> <span class="n">NuFFT</span><span class="p">:</span> <span class="mf">0.34364060000007157</span>
<span class="n">Embedded</span> <span class="ow">in</span> <span class="n">FFT</span><span class="p">:</span> <span class="mf">0.012971800000741496</span>
<span class="n">Periodic</span> <span class="n">NFFT</span><span class="p">:</span> <span class="mf">0.28861529999994673</span>
<span class="n">Direct</span> <span class="n">estimation</span><span class="p">:</span> <span class="mf">8.16284959999939</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">ndft</span>
<span class="kn">import</span> <span class="nn">util</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">])</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>

<span class="n">freqs</span><span class="p">,</span> <span class="n">psd</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">psd_with_freqs</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">,</span> <span class="n">ndft_fun</span><span class="o">=</span><span class="n">ndft</span><span class="o">.</span><span class="n">exe_ndft_fft</span><span class="p">,</span>
    <span class="n">max_freq</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">lags</span><span class="p">,</span> <span class="n">acf</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">acf_with_lags</span><span class="p">(</span>
    <span class="n">psd</span><span class="o">=</span><span class="n">psd</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">,</span> <span class="n">ndft_fun</span><span class="o">=</span><span class="n">ndft</span><span class="o">.</span><span class="n">exe_ndft_fft</span><span class="p">,</span>
    <span class="n">max_freq</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">max_lag</span><span class="o">=</span><span class="mf">.4</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">freqs</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">psd</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">lags</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">acf</span><span class="p">)</span>
</pre></div>
</div>
<p>This example shows how the utility methods automatically determine the correct output units, as long as <code class="docutils literal notranslate"><span class="pre">max_freq</span></code> is set correctly (it should be equal to the base samping rate, or twice the Nyquist frequency). The outputs should be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mf">0.</span>  <span class="mf">2.5</span> <span class="mf">5.</span>  <span class="mf">7.5</span><span class="p">]</span>
<span class="p">[</span><span class="mf">0.</span> <span class="mf">2.</span> <span class="mf">0.</span> <span class="mf">2.</span><span class="p">]</span>
<span class="p">[</span><span class="mf">0.</span>  <span class="mf">0.1</span> <span class="mf">0.2</span> <span class="mf">0.3</span><span class="p">]</span>
<span class="p">[</span> <span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span>  <span class="mf">0.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span> <span class="o">-</span><span class="mf">1.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span>  <span class="mf">0.</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">]</span>
</pre></div>
</div>
</section>
</section>
<section id="common-issues">
<h1>Common Issues<a class="headerlink" href="#common-issues" title="Permalink to this headline"></a></h1>
<p>Ensure that arrays passed into library functions are NumPy arrays and <em>not</em> pure-Python arrays – if an unsupported operation is performed on a pure-Python array, a mysterious and hard-to-debug exception is thrown.</p>
</section>
<section id="overview-of-mathematical-concepts">
<h1>Overview of Mathematical Concepts<a class="headerlink" href="#overview-of-mathematical-concepts" title="Permalink to this headline"></a></h1>
<p>This library contains methods to estimate the power spectral density (PSD) and autocorrelation function (ACF) of nonuniformly-sampled data using the nonuniform discrete Fourier transform (NDFT), which is a generalisation of the discrete Fourier transform (DFT). For detail such as conventions used, see the information below.</p>
<section id="the-dft">
<h2>The DFT<a class="headerlink" href="#the-dft" title="Permalink to this headline"></a></h2>
<p>Let <span class="math notranslate nohighlight">\((X_k)\)</span> be a length-<span class="math notranslate nohighlight">\(N\)</span> complex-valued vector. Its <strong>discrete Fourier transform</strong> is a length-<span class="math notranslate nohighlight">\(N\)</span> vector <span class="math notranslate nohighlight">\((\hat{X}_k)\)</span> given by</p>
<div class="math notranslate nohighlight">
\[\hat{X}_s=\sum_{r=0}^N\exp\left(-\frac{2\pi i}{N}\cdot rs\right)X_r.\]</div>
<p>The DFT estimates the Fourier transform of a periodic continuous signal sampled at discrete uniform times. Indeed, if the signal <span class="math notranslate nohighlight">\(X(t)\)</span> is periodic with period <span class="math notranslate nohighlight">\(N\)</span> sampled at integral times so that <span class="math notranslate nohighlight">\(X_k=X(k)\)</span>, then its DFT estimates the Fourier transform <span class="math notranslate nohighlight">\(\hat{X}(t)\)</span> of <span class="math notranslate nohighlight">\(X\)</span> at <span class="math notranslate nohighlight">\(N\)</span> equispaced frequencies in the range <span class="math notranslate nohighlight">\([0,1)\)</span>:</p>
<div class="math notranslate nohighlight">
\[\hat{X}_k\approx\hat{X}\left(\frac{k}{N}\right).\]</div>
<p>Note that frequencies outside the range <span class="math notranslate nohighlight">\([0,1)\)</span> are aliased to frequencies within this range by Nyquist’s theorem.</p>
<p>In general, a DFT can be evaulated directly in <span class="math notranslate nohighlight">\(\mathcal{O}(n^2)\)</span> time. A DFT of length <span class="math notranslate nohighlight">\(2^k\)</span> can be calculated in <span class="math notranslate nohighlight">\(\mathcal{O}(N\log N)\)</span> time using the fast Fourier transform (FFT) algorithm, and can be evaluated almost as quickly if <span class="math notranslate nohighlight">\(N\)</span> has no large prime factors. If the value of <span class="math notranslate nohighlight">\(N\)</span> is computationally inconvenient, the vector <span class="math notranslate nohighlight">\((X_k)\)</span> can be padded with zeroes to any desired length; this will change the output (as the value of <span class="math notranslate nohighlight">\(N\)</span> will change), as well as the interpretation (the frequencies will now be different), but no information about the signal will be lost.</p>
</section>
<section id="the-ndft">
<h2>The NDFT<a class="headerlink" href="#the-ndft" title="Permalink to this headline"></a></h2>
<p>If the signal <span class="math notranslate nohighlight">\(X(t)\)</span> is instead sampled at nonuniformly-spaced discrete times <span class="math notranslate nohighlight">\(t_1,\dots,t_N\)</span>, then its Fourier transform at arbitrary frequencies <span class="math notranslate nohighlight">\(f_1,\dots,f_M\)</span> can be estimated by a more general method. Indeed, given a length-<span class="math notranslate nohighlight">\(N\)</span> complex-valued vector <span class="math notranslate nohighlight">\((X_k)\)</span>, its <strong>nonuniform discrete Fourier transform</strong> is a length-<span class="math notranslate nohighlight">\(M\)</span> vector <span class="math notranslate nohighlight">\((\hat{X}_k)\)</span> given by</p>
<div class="math notranslate nohighlight">
\[\hat{X}_s=\sum_{r=0}^N\exp(-2\pi i\cdot t_r f_s)X_r.\]</div>
<p>Note that the NDFT reduces the the DFT in the case <span class="math notranslate nohighlight">\(t_k=k\)</span> and <span class="math notranslate nohighlight">\(f_k=k/N\)</span>.  Nyquist’s theorem does not constrain the choice of frequencies so much in this case, since the Nyquist frequency is <span class="math notranslate nohighlight">\(1/2d\)</span> where <span class="math notranslate nohighlight">\(d&gt;0\)</span> is the “highest common factor” of the <span class="math notranslate nohighlight">\(t_k\)</span>, that is, the largest value that each <span class="math notranslate nohighlight">\(t_k\)</span> is an integer multiple of.</p>
<p>The NDFT can be evaluated directly in <span class="math notranslate nohighlight">\(\mathcal{O}(mn)\)</span> time (<a class="reference internal" href="#ndft.exe_ndft" title="ndft.exe_ndft"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ndft.exe_ndft()</span></code></a>), and there are approximate algorithms (called NuFFTs) which use interpolation and the FFT to calculate an approximation in <span class="math notranslate nohighlight">\(\mathcal{O}(m\log m)\)</span> time (<a class="reference internal" href="#ndft.exe_nfft_py" title="ndft.exe_nfft_py"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ndft.exe_nfft_py()</span></code></a>). In this case, the frequencies <span class="math notranslate nohighlight">\(f_k\)</span> must be uniformly spaced, and generally <span class="math notranslate nohighlight">\(m\)</span> should be much larger than <span class="math notranslate nohighlight">\(n\)</span>. Alternatively, if the times <span class="math notranslate nohighlight">\(t_k\)</span> are all integer multiples of some factor <span class="math notranslate nohighlight">\(d\)</span>, then the NDFT can be embedded in a large DFT with times <span class="math notranslate nohighlight">\(\tilde{t}_k=kd\)</span> and missing values of <span class="math notranslate nohighlight">\(X(\tilde{t}_k)\)</span> set to zero (<a class="reference internal" href="#ndft.exe_ndft_fft" title="ndft.exe_ndft_fft"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ndft.exe_ndft_fft()</span></code></a>). This is often the case in practice, since the finite time-resolution of measuring devices serves as a suitable common factor.</p>
<p>Suppose now that the times <span class="math notranslate nohighlight">\(t_k\)</span> have been embedded in a regular sequence <span class="math notranslate nohighlight">\(\tilde{t}_k=kd\)</span>, as above. The associated DFT will have a size of approximately <span class="math notranslate nohighlight">\((t_N-t_1)/d\)</span>, so if <span class="math notranslate nohighlight">\(d\)</span> is relatively large then evaluation is very fast due to the FFT. Since the sampling is nonuniform, some values of <span class="math notranslate nohighlight">\(X(\tilde{t}_k)\)</span> will be missing; if the pattern of missing values is periodic, a further increase in efficiency can be made by exploiting the way in which the DFT factors. More precisely, let <span class="math notranslate nohighlight">\(N=q\times L\)</span>, with <span class="math notranslate nohighlight">\(q\)</span> sample times per period <span class="math notranslate nohighlight">\(p\)</span>. Then the sample times can be written <span class="math notranslate nohighlight">\(t_{aq+b}=(ap+T_b)d\)</span>, where <span class="math notranslate nohighlight">\(0\leq b&lt;q\)</span>. Setting the frequencies to <span class="math notranslate nohighlight">\(f_k=k/(Nd)\)</span>, the NDFT of <span class="math notranslate nohighlight">\((X_k)\)</span> can be written</p>
<div class="math notranslate nohighlight">
\[\hat{X}_s=\sum_{a=0}^L\exp\left(-\frac{2\pi i}{N}\cdot aps\right)\sum_{b=0}^q\exp\left(-\frac{2\pi i}{N}\cdot T_bs\right)X_{aq+b}.\]</div>
<p>For <span class="math notranslate nohighlight">\(q\ll m\)</span>, the above sum can be evaluated in <span class="math notranslate nohighlight">\(\mathcal{O}(qm\log m)\)</span> time (<a class="reference internal" href="#ndft.exe_nfft_per" title="ndft.exe_nfft_per"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ndft.exe_nfft_per()</span></code></a>). For comparison, computing the full associated DFT takes <span class="math notranslate nohighlight">\(\mathcal{O}(pm\log m)\)</span> time (when <span class="math notranslate nohighlight">\(p\ll m\)</span>), so this approach is especially advantageous for sparse nonuniform periodic sampling (with <span class="math notranslate nohighlight">\(q\ll p\)</span>).</p>
</section>
<section id="power-spectral-density">
<h2>Power Spectral Density<a class="headerlink" href="#power-spectral-density" title="Permalink to this headline"></a></h2>
<p>The <strong>power spectral density</strong> (PSD) <span class="math notranslate nohighlight">\(S_{XX}\)</span> of a wide-sense stationary signal <span class="math notranslate nohighlight">\(X\)</span> measures how the signal’s power is distributed over frequency (wide-sense stationarity means that the mean and variance of the signal remain constant). For a signal <span class="math notranslate nohighlight">\(X(t)\)</span> sampled at <span class="math notranslate nohighlight">\(N\)</span> integral times, the PSD at frequency <span class="math notranslate nohighlight">\(k/N\)</span> is estimated by</p>
<div class="math notranslate nohighlight">
\[S_{XX}\left(\frac{k}{N}\right)=\frac{\left|\hat{X}\left(k/N\right)\right|}{N}.\]</div>
<p>If <span class="math notranslate nohighlight">\(X\)</span> is instead sampled nonuniformly at times <span class="math notranslate nohighlight">\(t_i\)</span>, the above expression can be generalised to use the NDFT instead (<a class="reference internal" href="#ndft.calc_psd" title="ndft.calc_psd"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ndft.calc_psd()</span></code></a>). Other generalisations (such as the Lomb-Scargle periodogram) exist, but these generally take real data only.</p>
<p>The <strong>spectral window function</strong> <span class="math notranslate nohighlight">\(S_{1,1}\)</span> measures how regularly the signal is sampled modulo each frequency (<a class="reference internal" href="#ndft.spec_win" title="ndft.spec_win"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ndft.spec_win()</span></code></a>); here, <span class="math notranslate nohighlight">\(1\)</span> is the constant function sampled at the same times <span class="math notranslate nohighlight">\(t_i\)</span> as the signal. Periodicity in the sampling can cause aliasing and phantom peaks in the PSD estimates, and this effect can be reduced by deconvolution with <span class="math notranslate nohighlight">\(S_{1,1}\)</span> (<a class="reference internal" href="#ndft.calc_deconvolved_psd" title="ndft.calc_deconvolved_psd"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ndft.calc_deconvolved_psd()</span></code></a>). However, this operation is ill-conditioned, and accurate estimates can only be obtained if the ACF estimation (see next section) is accurate at all lags used.</p>
</section>
<section id="autocorrelation">
<h2>Autocorrelation<a class="headerlink" href="#autocorrelation" title="Permalink to this headline"></a></h2>
<p>The <strong>autocorrelation function</strong> (ACF) <span class="math notranslate nohighlight">\(R_{XX}(\tau)\)</span> of a signal <span class="math notranslate nohighlight">\(X\)</span> is defined to be the cross-correlation of <span class="math notranslate nohighlight">\(X\)</span> with a lagged copy of itself. In the case of nonuniform sampling at times <span class="math notranslate nohighlight">\(t_i\)</span>, some summands will be missing due to missing data:</p>
<div class="math notranslate nohighlight">
\[R_{XX}(\tau)=\sum_{k:\ X(t_k-\tau)\text{ exists}}X(t_k)\overline{X(t_k-\tau)}.\]</div>
<p>By the Weiner-Khinchin theorem, the ACF is also the Fourier transform of the PSD, and so it can be estimated by applying the FFT to a PSD estimate. The ACF can be normalised by the variance of the signal; assuming wide-sense stationarity, the variance of a signal at lag <span class="math notranslate nohighlight">\(\tau\)</span> is proportional to the number of gaps of length <span class="math notranslate nohighlight">\(\tau\)</span> in the sampling pattern of the signal, and so the normalised ACF <span class="math notranslate nohighlight">\(\overline{R}_{XX}(\tau)\)</span> can be estimated by</p>
<div class="math notranslate nohighlight">
\[\overline{R}_{XX}(\tau)=\frac{R_{XX}(\tau)}{R_{XX}(0)\cdot R_{1,1}(\tau)}.\]</div>
<p>Here, <span class="math notranslate nohighlight">\(R_{1,1}\)</span> is the FFT of the spectral window function <span class="math notranslate nohighlight">\(S_{1,1}\)</span> (<a class="reference internal" href="#ndft.lag_strength" title="ndft.lag_strength"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ndft.lag_strength()</span></code></a>), and <span class="math notranslate nohighlight">\(R_{XX}(0)\)</span> normalises <span class="math notranslate nohighlight">\(\overline{R}_{XX}(0)\)</span> to a value of <span class="math notranslate nohighlight">\(1\)</span>.</p>
<p>The direct cross-correlation calculation is implemented in <a class="reference internal" href="#util.direct_acf" title="util.direct_acf"><code class="xref py py-meth docutils literal notranslate"><span class="pre">util.direct_acf()</span></code></a>, whilst the spectral (PSD) method, which is in theory faster due to the FFT, is implemented in <code class="xref py py-meth docutils literal notranslate"><span class="pre">ndft.calc_ac()</span></code>. Note that, by default, the mean of the signal is not removed.</p>
</section>
<section id="arma-process">
<h2>ARMA Process<a class="headerlink" href="#arma-process" title="Permalink to this headline"></a></h2>
<p><strong>ARMA processes</strong> are a family of WSS random processes with known PSD and ACF; this makes them useful for examples and testing. An ARMA process <span class="math notranslate nohighlight">\((X_n)\)</span> with parameters <span class="math notranslate nohighlight">\((\phi_j)\)</span>, <span class="math notranslate nohighlight">\((\theta_k)\)</span> and <span class="math notranslate nohighlight">\(\sigma^2\)</span> can be generated recursively by</p>
<div class="math notranslate nohighlight">
\[X_n = \sum_{j=1}^p\phi_j X_{n-j}-\sum_{k=1}^q\theta_k W_{n-k},\]</div>
<p>where <span class="math notranslate nohighlight">\((W_n)\)</span> is white Gaussian noise with variance <span class="math notranslate nohighlight">\(\sigma^2\)</span>. In the implementation in <a class="reference internal" href="#arma.arma" title="arma.arma"><code class="xref py py-meth docutils literal notranslate"><span class="pre">arma.arma()</span></code></a>, the process <span class="math notranslate nohighlight">\((W_n)\)</span> is in fact complex white Gaussian noise.</p>
<p>This process is only stationary if the (complex) roots of the polynomial <span class="math notranslate nohighlight">\(1-\sum_j\phi_j x^j\)</span> all lie outside the unit circle.</p>
<p>The PSD of <span class="math notranslate nohighlight">\((X_n)\)</span> (<a class="reference internal" href="#arma.psd_exact" title="arma.psd_exact"><code class="xref py py-meth docutils literal notranslate"><span class="pre">arma.psd_exact()</span></code></a>) is given by</p>
<div class="math notranslate nohighlight">
\[S_{XX}(f)=\sigma^2\left|\frac{1-\hat{\phi}(f)}{1-\hat{\theta}(f)}\right|^2,\]</div>
<p>where <span class="math notranslate nohighlight">\(\hat{\phi}\)</span> and <span class="math notranslate nohighlight">\(\hat{\theta}\)</span> are the NDFTs of the vectors of parameters <span class="math notranslate nohighlight">\(\phi\)</span> and <span class="math notranslate nohighlight">\(\theta\)</span>.</p>
<p>If <span class="math notranslate nohighlight">\(\phi\)</span> and <span class="math notranslate nohighlight">\(\theta\)</span> are real-valued, the normalised ACF of <span class="math notranslate nohighlight">\((X_n)\)</span> (<a class="reference internal" href="#arma.acf_exact" title="arma.acf_exact"><code class="xref py py-meth docutils literal notranslate"><span class="pre">arma.acf_exact()</span></code></a>) at integer lags is real, and is given by the solution to the difference equation</p>
<div class="math notranslate nohighlight">
\[R_{XX}(\tau)=\sum_{j=1}^p\phi_j R_{XX}(f-j)\text{ for }\tau\geq p,\tau&gt;q,\]</div>
<p>with initial conditions</p>
<div class="math notranslate nohighlight">
\[R_{XX}(\tau)=\sum_{j=1}^p\phi_j R_{XX}(f-j)+\sigma^2\sum_{k=\tau}^q\theta_k\psi_{k-\tau}\text{ for }\tau&lt;\max(p,q+1),\]</div>
<p>where the <span class="math notranslate nohighlight">\(\psi_k\)</span> are the Taylor coefficients of the rational function</p>
<div class="math notranslate nohighlight">
\[\frac{1-\sum_k\theta_k x^k}{1-\sum_j\phi_j x^j}\equiv\sum_{r=0}^\infty\psi_r x^r.\]</div>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline"></a></h2>
<p>Bogacka, B. 2008. MTH6139 Time Series Lecture Notes. Queen Mary University of London. <a class="reference external" href="http://www.maths.qmul.ac.uk/~bb/TimeSeries/MAS328.html">http://www.maths.qmul.ac.uk/~bb/TimeSeries/MAS328.html</a> (accessed 2021-09-22).</p>
<p>Keiner, J., Kunis, S., and Potts, D. 2009. Using NFFT 3 — a software library for various non-equispaced fast Fourier transforms. ACM Trans. Math. Softw. 36, 4, Article 19 (August 2009), 30 pages. DOI: 10.1145/1555386.1555388. <a class="reference external" href="http://doi.acm.org/10.1145/1555386.1555388">http://doi.acm.org/10.1145/1555386.1555388</a>.</p>
<p>Percival, D., and Walden, A. 2020. Spectral Analysis for Univariate Time Series (Cambridge Series in Statistical and Probabilistic Mathematics). Cambridge: Cambridge University Press. DOI:10.1017/9781139235723</p>
<p>Van Loan, C. 1992. Computational Frameworks for the Fast Fourier Transform (Frontiers in Applied Mathematics). Philadelphia, PA, USA: Society for Industrial and Applied Mathematics.</p>
<p>Vityazev, V. V. 1996. Time series analysis of unequally spaced data: Intercomparison between the Schuster periodogram and the LS-spectra. Astronomical and Astrophysical Transactions, 11:2, 139-158. DOI: 10.1080/10556799608205461. <a class="reference external" href="https://www.tandfonline.com/doi/abs/10.1080/10556799608205461">https://www.tandfonline.com/doi/abs/10.1080/10556799608205461</a>.</p>
</section>
</section>
<section id="module-ndft">
<span id="methods"></span><h1>Methods<a class="headerlink" href="#module-ndft" title="Permalink to this headline"></a></h1>
<dl class="py function">
<dt class="sig sig-object py" id="ndft.DEFAULT_NDFT">
<span class="sig-prename descclassname"><span class="pre">ndft.</span></span><span class="sig-name descname"><span class="pre">DEFAULT_NDFT</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">os</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ndft.DEFAULT_NDFT" title="Permalink to this definition"></a></dt>
<dd><p>Calculates a fast approximation to the NDFT using the NFFT Python package. See <a class="reference internal" href="#ndft.exe_ndft" title="ndft.exe_ndft"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exe_ndft()</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ndft.calc_acf">
<span class="sig-prename descclassname"><span class="pre">ndft.</span></span><span class="sig-name descname"><span class="pre">calc_acf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psd</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lag_strengths</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_lag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm_lag_str</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm_var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ndft.calc_acf" title="Permalink to this definition"></a></dt>
<dd><p>Estimates the normalised autocorrelation of a signal <span class="math notranslate nohighlight">\(F(t)\)</span> using the NDFT.</p>
<p>The autocorrelation is calculated for lags <span class="math notranslate nohighlight">\(\tau_k=k\cdot f_{\text{max}}\)</span> in the range <span class="math notranslate nohighlight">\(0\leq\tau_k&lt;M\)</span>.
Any additional keyword arguments (such as <cite>times</cite>) are passed to the NDFT estimator <a class="reference internal" href="#ndft.calc_psd" title="ndft.calc_psd"><code class="xref py py-func docutils literal notranslate"><span class="pre">calc_psd()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>NumPy complex array</em>) – The values <span class="math notranslate nohighlight">\(F(t_i)\)</span> of the signal.</p></li>
<li><p><strong>psd</strong> (<em>NumPy real array</em>) – Optional pre-calculates PSDs (see <a class="reference internal" href="#ndft.calc_psd" title="ndft.calc_psd"><code class="xref py py-meth docutils literal notranslate"><span class="pre">calc_psd()</span></code></a>). If provided, <code class="docutils literal notranslate"><span class="pre">data</span></code> is ignored.
Note that, if this option is used and <code class="docutils literal notranslate"><span class="pre">lag_strengths</span></code> is not specified, the varargs passed to the original
<a class="reference internal" href="#ndft.calc_psd" title="ndft.calc_psd"><code class="xref py py-meth docutils literal notranslate"><span class="pre">calc_psd()</span></code></a> call should also be passed to this method, so that the right number of lag strengths can be
calculated.</p></li>
<li><p><strong>lag_strengths</strong> (<em>NumPy real array</em>) – Optional pre-calculated lag strengths (see <a class="reference internal" href="#ndft.lag_strength" title="ndft.lag_strength"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lag_strength()</span></code></a>). Recommended for
repeated calls with the same time sampling structure. If not enough lag strengths are provided, they will be
assumed to be periodic.</p></li>
<li><p><strong>max_freq</strong> (<em>float</em>) – The period <span class="math notranslate nohighlight">\(f_{\text{max}}\)</span> of the spectrum of <span class="math notranslate nohighlight">\(F\)</span> (i.e. twice the Nyquist frequency).
Should normally have value <span class="math notranslate nohighlight">\(1\)</span>.</p></li>
<li><p><strong>max_lag</strong> (<em>int</em>) – The maximum lag <span class="math notranslate nohighlight">\(M\)</span>.</p></li>
<li><p><strong>norm_lag_str</strong> (<em>bool</em>) – If <cite>False</cite>, does not perform normalisation by lag strength.</p></li>
<li><p><strong>norm_var</strong> (<em>bool</em>) – If <cite>False</cite>, does not perform normalisation by variance (value at lag 0).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An estimate of the (normalised) autocorrelation of <span class="math notranslate nohighlight">\(F(t)\)</span> for the first <cite>M</cite> integer
lags.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>NumPy complex array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ndft.calc_deconvolved_psd">
<span class="sig-prename descclassname"><span class="pre">ndft.</span></span><span class="sig-name descname"><span class="pre">calc_deconvolved_psd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ndft.calc_deconvolved_psd" title="Permalink to this definition"></a></dt>
<dd><p>Estimates the PSD of a signal <span class="math notranslate nohighlight">\(F(t)\)</span> by deconvolving its spectral window function from the naive estimate from the NDFT.</p>
<p>Note that this is ill-conditioned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>max_lag</strong> (<em>int</em>) – Deconvolution is truncated after this many steps. This should be set to the greatest lag at which
<a class="reference internal" href="#ndft.calc_acf" title="ndft.calc_acf"><code class="xref py py-func docutils literal notranslate"><span class="pre">calc_acf()</span></code></a> gives a good estimate for the autocovariance.</p>
</dd>
</dl>
<p>All other arguments and returns are as in <a class="reference internal" href="#ndft.calc_psd" title="ndft.calc_psd"><code class="xref py py-meth docutils literal notranslate"><span class="pre">calc_psd()</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ndft.calc_psd">
<span class="sig-prename descclassname"><span class="pre">ndft.</span></span><span class="sig-name descname"><span class="pre">calc_psd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ndft_fun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ndft.calc_psd" title="Permalink to this definition"></a></dt>
<dd><p>Estimates the PSD of a signal <span class="math notranslate nohighlight">\(F(t)\)</span> using the NDFT at equispaced points on <span class="math notranslate nohighlight">\([0,r)\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>NumPy complex array</em>) – The values <span class="math notranslate nohighlight">\(F(t_i)\)</span> of the signal.</p></li>
<li><p><strong>ndft_fun</strong> (<em>function</em>) – <p>The function that performs the NDFT.
Must take parameters <code class="docutils literal notranslate"><span class="pre">(data,</span> <span class="pre">max_freq)</span></code>, and return an estimate for the NDFT of <span class="math notranslate nohighlight">\(F\)</span>
at equispaced points on <span class="math notranslate nohighlight">\([0,r)\)</span>, in increasing order. Any additional keyword arguments
are passed to this function. This library provides several implementations:</p>
<blockquote>
<div><ul>
<li><p><a class="reference internal" href="#ndft.exe_ndft" title="ndft.exe_ndft"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exe_ndft()</span></code></a>: Exact NDFT</p></li>
<li><p><a class="reference internal" href="#ndft.exe_nfft_py" title="ndft.exe_nfft_py"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exe_nfft_py()</span></code></a>: Approximation to the NDFT implemented in Python</p></li>
<li><p><a class="reference internal" href="#ndft.exe_nfft_c" title="ndft.exe_nfft_c"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exe_nfft_c()</span></code></a>: Approximation to the NDFT implemented in C</p></li>
<li><p><a class="reference internal" href="#ndft.exe_ndft_fft" title="ndft.exe_ndft_fft"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exe_ndft_fft()</span></code></a>: NDFT evaluated by embedding in a larger FFT, possibly rounding the sample times.</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">exe_ndft_nfft_per()</span></code>: Exact NDFT for periodic nonuniform sampling.</p></li>
</ul>
</div></blockquote>
</p></li>
<li><p><strong>max_freq</strong> (<em>float</em>) – The maximum frequency <span class="math notranslate nohighlight">\(r\)</span>; must be positive.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An estimate of the PSD of <span class="math notranslate nohighlight">\(F(t)\)</span> at equispaced points on <span class="math notranslate nohighlight">\([0,r)\)</span>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>NumPy real array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ndft.exe_ndft">
<span class="sig-prename descclassname"><span class="pre">ndft.</span></span><span class="sig-name descname"><span class="pre">exe_ndft</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">os</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ndft.exe_ndft" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the exact NDFT of a signal <span class="math notranslate nohighlight">\(F(t)\)</span> sampled at <span class="math notranslate nohighlight">\(T\)</span> times <span class="math notranslate nohighlight">\(t_i\)</span>.</p>
<p>The output spectrum is sampled at <span class="math notranslate nohighlight">\(T\cdot k\)</span> equispaced frequencies on <span class="math notranslate nohighlight">\([0,r)\)</span>,
where <span class="math notranslate nohighlight">\(k\)</span> is the oversampling factor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>NumPy complex array</em>) – The sample values <span class="math notranslate nohighlight">\(F(t_i)\)</span>.</p></li>
<li><p><strong>max_freq</strong> (<em>float</em>) – The maximum frequency <span class="math notranslate nohighlight">\(r\)</span>; must be positive.</p></li>
<li><p><strong>times</strong> (<em>NumPy real array</em>) – The times <span class="math notranslate nohighlight">\(t_i\)</span>.</p></li>
<li><p><strong>os</strong> (<em>int</em>) – The oversampling factor <span class="math notranslate nohighlight">\(k\)</span>. Must be a positive integer.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ndft.exe_ndft_fft">
<span class="sig-prename descclassname"><span class="pre">ndft.</span></span><span class="sig-name descname"><span class="pre">exe_ndft_fft</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">times</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ndft.exe_ndft_fft" title="Permalink to this definition"></a></dt>
<dd><p>Calculates an exact NDFT using a large zero-interpolated FFT.</p>
<p>The time domain is rounded to steps of size <span class="math notranslate nohighlight">\(1/f_N\)</span>, where <span class="math notranslate nohighlight">\(f_N\)</span> is
the value of <code class="docutils literal notranslate"><span class="pre">max_freq</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>times</strong> (<em>NumPy real array</em>) – The sample times <span class="math notranslate nohighlight">\(t_i\)</span>, in increasing order.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ndft.exe_nfft_c">
<span class="sig-prename descclassname"><span class="pre">ndft.</span></span><span class="sig-name descname"><span class="pre">exe_nfft_c</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">os</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ndft.exe_nfft_c" title="Permalink to this definition"></a></dt>
<dd><p>Calculates a fast approximation to the NDFT using the pyNFFT Python wrapper for the NFFT3 C library.
See <a class="reference internal" href="#ndft.exe_ndft" title="ndft.exe_ndft"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exe_ndft()</span></code></a>.</p>
<p>Prone to memory errors.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ndft.exe_nfft_per">
<span class="sig-prename descclassname"><span class="pre">ndft.</span></span><span class="sig-name descname"><span class="pre">exe_nfft_per</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ndft.exe_nfft_per" title="Permalink to this definition"></a></dt>
<dd><p>Calculates an exact NDFT for periodic data.</p>
<p>This is a wrapper for <a class="reference internal" href="#periodic.nfft_per" title="periodic.nfft_per"><code class="xref py py-meth docutils literal notranslate"><span class="pre">periodic.nfft_per()</span></code></a>. Only frequency range <span class="math notranslate nohighlight">\(1\)</span> is supported as
integer times are assumed.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ndft.exe_nfft_py">
<span class="sig-prename descclassname"><span class="pre">ndft.</span></span><span class="sig-name descname"><span class="pre">exe_nfft_py</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">os</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ndft.exe_nfft_py" title="Permalink to this definition"></a></dt>
<dd><p>Calculates a fast approximation to the NDFT using the NFFT Python package. See <a class="reference internal" href="#ndft.exe_ndft" title="ndft.exe_ndft"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exe_ndft()</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ndft.lag_strength">
<span class="sig-prename descclassname"><span class="pre">ndft.</span></span><span class="sig-name descname"><span class="pre">lag_strength</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ndft.lag_strength" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the lag strengths of <span class="math notranslate nohighlight">\(t_i\)</span>. Arguments and returns are as in
<a class="reference internal" href="#ndft.calc_acf" title="ndft.calc_acf"><code class="xref py py-meth docutils literal notranslate"><span class="pre">calc_acf()</span></code></a>, except that <cite>data</cite>, <cite>psds</cite> and <cite>norm_lag_str</cite> cannot be given.</p>
<p>Equivalently, estimates the autocovariance of <span class="math notranslate nohighlight">\(F\equiv1\)</span>, sampled at times <span class="math notranslate nohighlight">\(t_i\)</span>,
using the NDFT, where <span class="math notranslate nohighlight">\(T\)</span> is the number of samples.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ndft.ndft_mat">
<span class="sig-prename descclassname"><span class="pre">ndft.</span></span><span class="sig-name descname"><span class="pre">ndft_mat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ndft.ndft_mat" title="Permalink to this definition"></a></dt>
<dd><p>Generates the NDFT matrix mapping data at times <span class="math notranslate nohighlight">\(t_i\)</span> to frequencies <span class="math notranslate nohighlight">\(f_j\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ts</strong> (<em>NumPy float array</em>) – The times <span class="math notranslate nohighlight">\(t_i\)</span>.</p></li>
<li><p><strong>fs</strong> (<em>NumPy float array</em>) – the frequencies <span class="math notranslate nohighlight">\(f_j\)</span> .</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The NDFT matrix.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>2D NumPy complex array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ndft.spec_win">
<span class="sig-prename descclassname"><span class="pre">ndft.</span></span><span class="sig-name descname"><span class="pre">spec_win</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">times</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ndft.spec_win" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the spectral window function of <span class="math notranslate nohighlight">\(t_i\)</span>. Arguments and returns are as in <a class="reference internal" href="#ndft.calc_psd" title="ndft.calc_psd"><code class="xref py py-meth docutils literal notranslate"><span class="pre">calc_psd()</span></code></a>.</p>
<p>Equivalently, estimates the PSD of <span class="math notranslate nohighlight">\(F\equiv1/T\)</span>, sampled at times <span class="math notranslate nohighlight">\(t_i\)</span>, using the NDFT,
where <span class="math notranslate nohighlight">\(T\)</span> is the number of samples.</p>
</dd></dl>

<span class="target" id="module-arma"></span><dl class="py function">
<dt class="sig sig-object py" id="arma.acf_exact">
<span class="sig-prename descclassname"><span class="pre">arma.</span></span><span class="sig-name descname"><span class="pre">acf_exact</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">phis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thetas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#arma.acf_exact" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the (theoretical) autocorrelation of an ARMA(p,q) process at integral lags from <span class="math notranslate nohighlight">\(0\)</span> to <span class="math notranslate nohighlight">\(N\)</span>, inclusive</p>
<p>Only works for real-valued parameters <span class="math notranslate nohighlight">\(\phi_i\)</span> and <span class="math notranslate nohighlight">\(\theta_i\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>phis</strong> (<em>NumPy float array</em>) – The AR parameters <span class="math notranslate nohighlight">\(\phi_i\)</span> (length <span class="math notranslate nohighlight">\(p\)</span>).</p></li>
<li><p><strong>thetas</strong> (<em>NumPy float array</em>) – The MA parameters <span class="math notranslate nohighlight">\(\theta_i\)</span> (length <span class="math notranslate nohighlight">\(q\)</span>).</p></li>
<li><p><strong>N</strong> (<em>int</em>) – Maximum lag <span class="math notranslate nohighlight">\(N\)</span> to calcuate the ACF for.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The autocorrelation function.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>NumPy complex array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="arma.arma">
<span class="sig-prename descclassname"><span class="pre">arma.</span></span><span class="sig-name descname"><span class="pre">arma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">phis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thetas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_sq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#arma.arma" title="Permalink to this definition"></a></dt>
<dd><p>Generates and returns the first N steps of a (complex) ARMA(p,q) process.</p>
<p>See <em>Spectral Analysis of Univariate Time Series</em> (Percival, Walden) p.35.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>phis</strong> (<em>NumPy complex array</em>) – The AR parameters <span class="math notranslate nohighlight">\(\phi_i\)</span> (length <span class="math notranslate nohighlight">\(p\)</span>)</p></li>
<li><p><strong>thetas</strong> (<em>NumPy complex array</em>) – The MA parameters <span class="math notranslate nohighlight">\(\theta_i\)</span> (length <span class="math notranslate nohighlight">\(q\)</span>).</p></li>
<li><p><strong>sigma_sq</strong> (<em>float</em>) – Variance of the underlying Gaussian noise.</p></li>
<li><p><strong>N</strong> (<em>int</em>) – Number of steps to generate.</p></li>
<li><p><strong>seed</strong> – Optional seed for the underlying noise.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The ARMA time series.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>NumPy complex array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="arma.psd_exact">
<span class="sig-prename descclassname"><span class="pre">arma.</span></span><span class="sig-name descname"><span class="pre">psd_exact</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">phis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thetas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_sq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freqs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#arma.psd_exact" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the (theoretical) PSD of an ARMA(p,q) process at the frequencies <span class="math notranslate nohighlight">\(f_i\)</span>.</p>
<p>See <em>Spectral Analysis of Univariate Time Series</em> (Percival, Walden) p.145.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>phis</strong> (<em>NumPy complex array</em>) – The AR parameters <span class="math notranslate nohighlight">\(\phi_i\)</span> (length <span class="math notranslate nohighlight">\(p\)</span>)</p></li>
<li><p><strong>thetas</strong> (<em>NumPy complex array</em>) – The MA parameters <span class="math notranslate nohighlight">\(\theta_i\)</span> (length <span class="math notranslate nohighlight">\(q\)</span>).</p></li>
<li><p><strong>sigma_sq</strong> (<em>float</em>) – Variance of the underlying Gaussian noise.</p></li>
<li><p><strong>freqs</strong> (<em>NumPy float array</em>) – The frequencies <span class="math notranslate nohighlight">\(f_i\)</span> to calculate the PSD at.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The PSD.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>NumPy float array</p>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-util"></span><dl class="py function">
<dt class="sig sig-object py" id="util.acf_with_lags">
<span class="sig-prename descclassname"><span class="pre">util.</span></span><span class="sig-name descname"><span class="pre">acf_with_lags</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#util.acf_with_lags" title="Permalink to this definition"></a></dt>
<dd><p>Wrapper for <a class="reference internal" href="#ndft.calc_acf" title="ndft.calc_acf"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ndft.calc_acf()</span></code></a> that also returns the period axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>threshold</strong> (<em>float</em>) – Minimum lag strength needed for an ACF estimate
to be returned at that lag. Must be in <span class="math notranslate nohighlight">\([0,1)\)</span>.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(lags, ACF)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(NumPy real array, NumPy complex array)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="util.benchmark">
<span class="sig-prename descclassname"><span class="pre">util.</span></span><span class="sig-name descname"><span class="pre">benchmark</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#util.benchmark" title="Permalink to this definition"></a></dt>
<dd><p>Returns the current value of the global timer, then restarts it.</p>
<p>If a title is supplied, displays the current value as well. Note
that the global timer <code class="docutils literal notranslate"><span class="pre">TIMER</span></code> is started on module load.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>title</strong> (<em>str</em>) – Optional timer title to display.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The current value of the timer in seconds, to millisecond precision.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="util.direct_acf">
<span class="sig-prename descclassname"><span class="pre">util.</span></span><span class="sig-name descname"><span class="pre">direct_acf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timestamps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxlag</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mincount</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">retcounts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">removemean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#util.direct_acf" title="Permalink to this definition"></a></dt>
<dd><p>Estimates the (normalised) autocovariance of the time series <span class="math notranslate nohighlight">\(F_j(t)\)</span>, sampled at the given times <cite>t_i</cite>.</p>
<p>The autocovariance at all sufficiently common gaps of length <span class="math notranslate nohighlight">\(0\leq\tau\leq m\)</span> is estimated.
Written by Keith Briggs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>2D NumPy complex array</em>) – The input data: index <code class="docutils literal notranslate"><span class="pre">(i,j)</span></code> is <span class="math notranslate nohighlight">\(F_j(t_i)\)</span></p></li>
<li><p><strong>timestamps</strong> (<em>Numpy float array</em>) – The times <span class="math notranslate nohighlight">\(t_i\)</span>; must be sorted in increasing order.
Must be relatively low precision (e.g. integers) for meaningful results.</p></li>
<li><p><strong>maxlag</strong> (<em>float</em>) – The maximal lag <span class="math notranslate nohighlight">\(m\)</span> to measure the autocovariance at.</p></li>
<li><p><strong>mincount</strong> (<em>int</em>) – The minimal number of gaps of a certain lag that must exist for
the autocovariance at that lag to be estimated.</p></li>
<li><p><strong>retcounts</strong> (<em>bool</em>) – If <cite>True</cite>, additionally returns the number of gaps at each lag.</p></li>
<li><p><strong>removemean</strong> (<em>bool</em>) – If <cite>False</cite>, does not remove the mean of the data and so calculates
autocorrelation instead.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Dictionary mapping lags to autocovariances. If a key is missing,
then either the lag does not appear often enough to get a reasonable estimate, or the lag is out of range.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict from float to complex</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="util.gen_paths">
<span class="sig-prename descclassname"><span class="pre">util.</span></span><span class="sig-name descname"><span class="pre">gen_paths</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_depth</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#util.gen_paths" title="Permalink to this definition"></a></dt>
<dd><p>Generates all (simple) paths of length <span class="math notranslate nohighlight">\(k\)</span> or less through
the complete graph with <span class="math notranslate nohighlight">\(N\)</span> vertices.</p>
<p>Equivalenty, generates all combinations of <span class="math notranslate nohighlight">\(\{0,\dots,N-1\}\)</span> of length less
than <span class="math notranslate nohighlight">\(k\)</span> where all adjacent values are distinct. Used to find possible signal
paths in a multipath model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>N</strong> (<em>int</em>) – The number of vertices in the graph.</p></li>
<li><p><strong>max_depth</strong> (<em>int</em>) – The maximum path length.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A generator for the paths, specified by the vertices visited in order.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>generator of lists of integers</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="util.paths">
<span class="sig-prename descclassname"><span class="pre">util.</span></span><span class="sig-name descname"><span class="pre">paths</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cur</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rem_depth</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#util.paths" title="Permalink to this definition"></a></dt>
<dd><p>Recursive helper function for <a class="reference internal" href="#util.gen_paths" title="util.gen_paths"><code class="xref py py-meth docutils literal notranslate"><span class="pre">gen_paths()</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="util.plot_sampled_data">
<span class="sig-prename descclassname"><span class="pre">util.</span></span><span class="sig-name descname"><span class="pre">plot_sampled_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Unknown'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">db</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#util.plot_sampled_data" title="Permalink to this definition"></a></dt>
<dd><p>Plots the mean of the 2D data <code class="docutils literal notranslate"><span class="pre">ys</span></code> against <code class="docutils literal notranslate"><span class="pre">xs</span></code> on axes <code class="docutils literal notranslate"><span class="pre">ax</span></code>, with error bars of one standard deviation.</p>
<p>Requires pyplot to be installed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>NumPy array</em>) – The x-axis (independent) data.</p></li>
<li><p><strong>y</strong> (<em>2D NumPy array</em>) – The y-axis (dependent) data; the columns are the individual data series.</p></li>
<li><p><strong>ax</strong> (<em>Pyplot axes object</em>) – The axes to plot on.</p></li>
<li><p><strong>label</strong> (<em>str</em>) – The data label.</p></li>
<li><p><strong>db</strong> (<em>bool</em>) – If <cite>True</cite>, converts the y-axis to logarithmic units.</p></li>
<li><p><strong>symmetric</strong> (<em>True</em>) – If <cite>True</cite>, discards the second half of the data. Use if data is symmetric.</p></li>
</ul>
</dd>
</dl>
<p>Any keyword arguments are passed to the <code class="docutils literal notranslate"><span class="pre">pyplot.plot</span></code> and <code class="docutils literal notranslate"><span class="pre">pyplot.fillbetween</span></code> methods. Do not pass <code class="docutils literal notranslate"><span class="pre">alpha</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="util.psd_with_freqs">
<span class="sig-prename descclassname"><span class="pre">util.</span></span><span class="sig-name descname"><span class="pre">psd_with_freqs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#util.psd_with_freqs" title="Permalink to this definition"></a></dt>
<dd><p>Wrapper for <a class="reference internal" href="#ndft.calc_psd" title="ndft.calc_psd"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ndft.calc_psd()</span></code></a> that also returns the frequency axis.
:returns: (frequencies, PSD)
:rtype: (NumPy real array, NumPy complex array)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="util.to_db">
<span class="sig-prename descclassname"><span class="pre">util.</span></span><span class="sig-name descname"><span class="pre">to_db</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#util.to_db" title="Permalink to this definition"></a></dt>
<dd><p>Converts data from linear to logarithmic units.</p>
<p>If data is supplied in Watts, output is in dBmW.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> (<em>NumPy nD array</em>) – Data to convert.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The converted data.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>NumPy nD array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="util.unif_pts">
<span class="sig-prename descclassname"><span class="pre">util.</span></span><span class="sig-name descname"><span class="pre">unif_pts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#util.unif_pts" title="Permalink to this definition"></a></dt>
<dd><p>Generates <span class="math notranslate nohighlight">\(N\)</span> uniformly-spaced points on <span class="math notranslate nohighlight">\([0,m)\)</span>.</p>
<p>Used to generate frequency axis for PSD.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>N</strong> (<em>int</em>) – The value of <span class="math notranslate nohighlight">\(N\)</span>.</p></li>
<li><p><strong>max</strong> (<em>float</em>) – The value of <span class="math notranslate nohighlight">\(m\)</span>. Must be positive.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-periodic"></span><dl class="py function">
<dt class="sig sig-object py" id="periodic.dft_mat">
<span class="sig-prename descclassname"><span class="pre">periodic.</span></span><span class="sig-name descname"><span class="pre">dft_mat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sgn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#periodic.dft_mat" title="Permalink to this definition"></a></dt>
<dd><p>Generates an <span class="math notranslate nohighlight">\(n\times n\)</span> DFT matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<em>int</em>) – The matrix size <span class="math notranslate nohighlight">\(n\)</span>.</p></li>
<li><p><strong>sgn</strong> (<em>float</em>) – The sign convention to use; must be <span class="math notranslate nohighlight">\(\pm1\)</span>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="periodic.fft">
<span class="sig-prename descclassname"><span class="pre">periodic.</span></span><span class="sig-name descname"><span class="pre">fft</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#periodic.fft" title="Permalink to this definition"></a></dt>
<dd><p>Mixed-radix FFT implementation.</p>
<p>Uses the (mixed-radix) Cooley-Tukey algorithm; see <em>Computational frameworks for the FFT</em> (Van Loan) p.81.
Calculates a factorisation recursively at runtime.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inp</strong> (<em>NumPy complex array</em>) – The input vector.</p></li>
<li><p><strong>N</strong> (<em>int</em>) – The length of <code class="docutils literal notranslate"><span class="pre">inp</span></code>.</p></li>
<li><p><strong>threshold</strong> (<em>int</em>) – The maximum size at which to compute the DFT directly instead of
attempting to factorise.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The FFT of <code class="docutils literal notranslate"><span class="pre">inp</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>NumPy complex array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="periodic.ndft_mat">
<span class="sig-prename descclassname"><span class="pre">periodic.</span></span><span class="sig-name descname"><span class="pre">ndft_mat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sgn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#periodic.ndft_mat" title="Permalink to this definition"></a></dt>
<dd><p>Generates an <span class="math notranslate nohighlight">\(p\times q\)</span> NDFT matrix consisting of columns
<span class="math notranslate nohighlight">\(k_1,\dots,k_q\)</span> of a <span class="math notranslate nohighlight">\(p\times p\)</span> DFT matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pattern</strong> (<em>int array</em>) – The columns <span class="math notranslate nohighlight">\(k_1,\dots,k_q\)</span> to use; must be integers in <cite>[0,p)</cite>.</p></li>
<li><p><strong>p</strong> (<em>int</em>) – The dimension <span class="math notranslate nohighlight">\(p\)</span>.</p></li>
<li><p><strong>sgn</strong> (<em>float</em>) – The sign convention to use; must be <span class="math notranslate nohighlight">\(\pm1\)</span>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="periodic.nfft_per">
<span class="sig-prename descclassname"><span class="pre">periodic.</span></span><span class="sig-name descname"><span class="pre">nfft_per</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#periodic.nfft_per" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the NDFT of a signal <span class="math notranslate nohighlight">\(F(t)\)</span> sampled at integer times <cite>t_i</cite>, where the sampling is
periodic with integer period <span class="math notranslate nohighlight">\(p\)</span>, with structure given by <code class="docutils literal notranslate"><span class="pre">mask</span></code>.</p>
<p>More precisely, <span class="math notranslate nohighlight">\(t\in(t_i)\)</span> iff <code class="docutils literal notranslate"><span class="pre">mask[t%b]==True</span></code>.</p>
<p>This is a wrapper for <a class="reference internal" href="#periodic.nfft_per_pattern" title="periodic.nfft_per_pattern"><code class="xref py py-meth docutils literal notranslate"><span class="pre">nfft_per_pattern()</span></code></a>, and any keyword arguments are passed to that function.
The data is padded so that it contains a whole number of periods.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>NumPy complex array</em>) – The values <span class="math notranslate nohighlight">\(F(t_i)\)</span> of the signal.</p></li>
<li><p><strong>mask</strong> (<em>bool array</em>) – A length-<span class="math notranslate nohighlight">\(p\)</span> array with value <cite>True</cite> whenever that time is a sample
time in <span class="math notranslate nohighlight">\((t_i)\)</span>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The NDFT of the vector <span class="math notranslate nohighlight">\(F(t_i)\)</span>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>NumPy complex array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="periodic.nfft_per_pattern">
<span class="sig-prename descclassname"><span class="pre">periodic.</span></span><span class="sig-name descname"><span class="pre">nfft_per_pattern</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">inp</span></em>, <em class="sig-param"><span class="pre">pattern</span></em>, <em class="sig-param"><span class="pre">p</span></em>, <em class="sig-param"><span class="pre">dft_fun=&lt;function</span> <span class="pre">fft&gt;</span></em>, <em class="sig-param"><span class="pre">**kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#periodic.nfft_per_pattern" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the NDFT of a signal <span class="math notranslate nohighlight">\(F(t)\)</span> sampled at integer times <cite>t_i</cite>, where the sampling is
periodic with integer period <span class="math notranslate nohighlight">\(p\)</span>.</p>
<p>More precisely, let there be <span class="math notranslate nohighlight">\(q\)</span> sample times <span class="math notranslate nohighlight">\(t_1,\dots,t_q\)</span> in <span class="math notranslate nohighlight">\([0,p)\)</span>. Then <span class="math notranslate nohighlight">\(t_{aq+b}=ap+t_b\)</span>.
Note that the signal must be sampled over a whole number of periods, that is, the length of <code class="docutils literal notranslate"><span class="pre">inp</span></code> must be a multiple
of <span class="math notranslate nohighlight">\(q\)</span>.</p>
<p>The algorithm is based off the mixed-radix Cooley-Tukey algorithm; compare <a class="reference internal" href="#periodic.fft" title="periodic.fft"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fft()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inp</strong> (<em>NumPy complex array</em>) – The values <span class="math notranslate nohighlight">\(F(t_i)\)</span> of the signal.
pattern (int array): The (integer) sample times <span class="math notranslate nohighlight">\(t_1,\dots,t_q\)</span> in the range <span class="math notranslate nohighlight">\([0,p)\)</span>.</p></li>
<li><p><strong>p</strong> (<em>int</em>) – The period <span class="math notranslate nohighlight">\(p\)</span> of the sampling.</p></li>
<li><p><strong>dft_fun</strong> (<em>function</em>) – A function that performs a DFT; must take parameters <code class="docutils literal notranslate"><span class="pre">(data,</span> <span class="pre">N)</span></code>, where <code class="docutils literal notranslate"><span class="pre">N</span></code>
is the length of <code class="docutils literal notranslate"><span class="pre">data</span></code>, and return the DFT of <code class="docutils literal notranslate"><span class="pre">data</span></code>. Any keyword arguments are passed to
this function.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The NDFT of the vector <span class="math notranslate nohighlight">\(F(t_i)\)</span>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>NumPy complex array</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="indices">
<h1>Indices<a class="headerlink" href="#indices" title="Permalink to this headline"></a></h1>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Artem Khovanov and Keith Briggs.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>