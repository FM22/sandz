.. Documentation master file, created by
   sphinx-quickstart on Fri Aug 20 20:47:27 2021.
   You can adapt this file completely to your liking, but it should at least
   contain the root `toctree` directive.

Documentation for SANDZ
=======================

Last modified: |today|

..
    .. toctree::
       :maxdepth: 2
       :caption: Contents:
       :hidden:

       index

This is a library for performing spectral analysis on nonuniformly-sampled data using the nonuniform discrete Fourier transform (NDFT).

Requirements
============
* NumPy and SciPy are required.
* One of pynfft or nfft is recommended (alternatively, a custom NFFT implementation can be used).
* SymPy is required for :meth:`arma.acf_exact`.
* Pyplot is required for :meth:`util.plot_sampled_data`.

Example usage
=============
::

    import ndft
    import arma
    import util
    import numpy as np
    np.random.seed(0)

    length = 1000
    inds = np.sort(np.random.choice(
        np.arange(length), length//2, replace=False))
    times = np.arange(length)[inds]
    arma_params = (
        np.array([2.7607, -3.8106, 2.6535, -0.9238]), np.empty(0), 1)

    full_data = arma.arma(*arma_params, length, seed=0)
    data = full_data[inds]

    (freqs, psd) = util.psd_with_freqs(
        data, times=times, ndft_fun=ndft.exe_ndft_fft)
    (lags, acf) = util.acf_with_lags(
        psd=psd, times=times, ndft_fun=ndft.exe_ndft_fft)

    true_psd = arma.psd_exact(*arma_params, freqs)
    true_acf = arma.acf_exact(*arma_params[:-1], len(lags)-1)

    psd_pwr = util.to_db(psd)
    true_psd_pwr = util.to_db(true_psd)

This code estimates the PSD and ACF of a time series generated by the example ARMA model on p.35 of *Spectral Analysis of Univariate Time Series* (Percival, Walden), with half of entries removed at random. The estimates can be displayed using the following code, which requires pyplot:

.. code-block:: python

    import matplotlib.pyplot as plt

    ax = plt.subplot()
    ax.plot(freqs, psd_pwr, label="Estimated PSD")
    ax.plot(freqs, true_psd_pwr, label="True PSD", alpha=.8)
    ax.set_xlabel("Frequency")
    ax.set_ylabel("PSD (dB)")
    ax.legend()
    ax.set(xlim=[0,1])
    plt.figure()
    ax = plt.subplot()
    ax.plot(lags, np.real(acf), label="Estimated ACF")
    ax.plot(lags, true_acf, label="True ACF", alpha=.8)
    ax.set_xlabel("Lag")
    ax.set_ylabel("Normalised\n autocorrelation")
    ax.legend()
    ax.set(ylim=[-1.2,1.2])
    ax.grid(color='gray', alpha=0.5, lw=0.5)
    plt.show()

This gives the plots:

.. image:: _static/psd_example.png
  :width: 600
  :alt: Example plot of PSD
  
.. image:: _static/acf_example.png
  :width: 600
  :alt: Example plot of ACF


Further Examples
----------------
Here are some further examples. The first two again require pyplot to display the outputs. All of these examples can also be found in ``examples.py``.

.. code-block:: python

    import ndft
    import arma
    import util
    import numpy as np
    import matplotlib.pyplot as plt
    np.random.seed(0)

    iterations = 100
    gen_len = 1000
    arma_params = (np.array([2.7607, -3.8106, 2.6535, -0.9238]), np.array([.9j, 1.1j]), 1)

    dropout_pattern = [True, True, False, True, False, True, True, True, True, True]
    dropout_pattern *=  gen_len//len(dropout_pattern)
    full_times = np.arange(gen_len)
    times_vec = [
        full_times, full_times[dropout_pattern], full_times[dropout_pattern]]
    labels = ["No missing data", "Periodic gaps", "Periodic gaps (deconvolved)"]

    psd = [None]*len(times_vec)
    for i, times in enumerate(times_vec):
        psd[i] = [None]*iterations
        for j in range(iterations):
            data = arma.arma(
                *arma_params, gen_len, 
                seed=np.random.randint(2**16))[times_vec[i]]
            if i == 2:
                psd[i][j] = ndft.calc_deconvolved_psd(data, times=times_vec[i])
            else:
                psd[i][j] = ndft.calc_psd(data, times=times_vec[i]) 

    ax = plt.subplot()
    for i in range(len(times_vec)):
        util.plot_sampled_data(
            util.unif_pts(
                len(psd[i][0])), np.array(psd[i]), ax, 
                label=labels[i], db=True, symmetric=False)
    freqs = util.unif_pts(gen_len)
    ax.plot(
        freqs, util.to_db(arma.psd_exact(*arma_params, freqs)),
        label="True value", color='black')
    ax.set(xlim=[0,1], ylim=[0,100])
    ax.legend(loc='lower right')
    ax.set_xlabel("Frequency")
    ax.set_ylabel("PSD (dB)")
    plt.show()

.. image:: _static/deconv_example.png
  :width: 600
  :alt: Example of PSD deconvolution

This example shows how spectral estimation of data with periodic gaps can be improved using deconvolution. Note also the lack of aliasing (symmetry) until *twice* the Nyquist frequency, which is :math:`0.5` -- this only occurs when the signal is complex.

.. code-block:: python

    import ndft
    import util
    import numpy as np
    import matplotlib.pyplot as plt
    np.random.seed(0)

    length = 33333
    mask = [True, True, False]
    times = np.arange(length)[mask * (length//len(mask))]
    data = np.exp(2j*np.pi*.3*times) +\
        np.exp(2j*np.pi*.4*times) +\
        np.exp(2j*np.pi*.8*times) +\
        np.random.normal((len(times)))*0.01
    
    acfs = [None]*4
    labels = [
        "Approximate NuFFT", "Embedded in FFT", 
        "Periodic NFFT", "Direct estimation"]
    util.benchmark()
    acfs[0] = np.real(ndft.calc_acf(
        data=data, times=times, ndft_fun=ndft.exe_nfft_py))
    util.benchmark(labels[0])
    acfs[1] = np.real(ndft.calc_acf(
        data=data, times=times, ndft_fun=ndft.exe_ndft_fft))
    util.benchmark(labels[1])
    acfs[2] = np.real(ndft.calc_acf(
        data=data, mask=mask, ndft_fun=ndft.exe_nfft_per))
    util.benchmark(labels[2])
    acfs[3] = [np.real(v) for v in util.direct_acf(
        data, times, ndft.MAX_LAG-1).values()]
    util.benchmark(labels[3])

    for i, acf in enumerate(acfs):
        plt.plot(np.arange(ndft.MAX_LAG), acf, label=labels[i])
    plt.legend(loc='lower right')
    plt.show()

This example demonstrates the difference in speed and output of the various NDFT implementations. On my machine, the output to the terminal was:

::

    Approximate NuFFT: 0.34364060000007157
    Embedded in FFT: 0.012971800000741496
    Periodic NFFT: 0.28861529999994673
    Direct estimation: 8.16284959999939

.. code-block:: python

    import ndft
    import util
    import numpy as np

    times = np.array([0, 0.1, 0.2, 0.3])
    data = np.array([1,-1,-1,1])

    freqs, psd = util.psd_with_freqs(
        data, times=times, ndft_fun=ndft.exe_ndft_fft, 
        max_freq=10)
    lags, acf = util.acf_with_lags(
        psd=psd, times=times, ndft_fun=ndft.exe_ndft_fft, 
        max_freq=10, max_lag=.4)

    print(freqs)
    print(psd)
    print(lags)
    print(acf)

This example shows how the utility methods automatically determine the correct output units, as long as ``max_freq`` is set correctly (it should be equal to the base samping rate, or twice the Nyquist frequency). The outputs should be:

::

    [0.  2.5 5.  7.5]
    [0. 2. 0. 2.]
    [0.  0.1 0.2 0.3]
    [ 1.+0.j  0.+0.j -1.+0.j  0.+0.j]

Common Issues
=============
Ensure that arrays passed into library functions are NumPy arrays and *not* pure-Python arrays -- if an unsupported operation is performed on a pure-Python array, a mysterious and hard-to-debug exception is thrown.

Overview of Mathematical Concepts
=================================
This library contains methods to estimate the power spectral density (PSD) and autocorrelation function (ACF) of nonuniformly-sampled data using the nonuniform discrete Fourier transform (NDFT), which is a generalisation of the discrete Fourier transform (DFT). For detail such as conventions used, see the information below.

The DFT
-------
Let :math:`(X_k)` be a length-:math:`N` complex-valued vector. Its **discrete Fourier transform** is a length-:math:`N` vector :math:`(\hat{X}_k)` given by

.. math::

    \hat{X}_s=\sum_{r=0}^N\exp\left(-\frac{2\pi i}{N}\cdot rs\right)X_r.

The DFT estimates the Fourier transform of a periodic continuous signal sampled at discrete uniform times. Indeed, if the signal :math:`X(t)` is periodic with period :math:`N` sampled at integral times so that :math:`X_k=X(k)`, then its DFT estimates the Fourier transform :math:`\hat{X}(t)` of :math:`X` at :math:`N` equispaced frequencies in the range :math:`[0,1)`:  

.. math::

    \hat{X}_k\approx\hat{X}\left(\frac{k}{N}\right).

Note that frequencies outside the range :math:`[0,1)` are aliased to frequencies within this range by Nyquist's theorem.

In general, a DFT can be evaulated directly in :math:`\mathcal{O}(n^2)` time. A DFT of length :math:`2^k` can be calculated in :math:`\mathcal{O}(N\log N)` time using the fast Fourier transform (FFT) algorithm, and can be evaluated almost as quickly if :math:`N` has no large prime factors. If the value of :math:`N` is computationally inconvenient, the vector :math:`(X_k)` can be padded with zeroes to any desired length; this will change the output (as the value of :math:`N` will change), as well as the interpretation (the frequencies will now be different), but no information about the signal will be lost.

The NDFT
--------
If the signal :math:`X(t)` is instead sampled at nonuniformly-spaced discrete times :math:`t_1,\dots,t_N`, then its Fourier transform at arbitrary frequencies :math:`f_1,\dots,f_M` can be estimated by a more general method. Indeed, given a length-:math:`N` complex-valued vector :math:`(X_k)`, its **nonuniform discrete Fourier transform** is a length-:math:`M` vector :math:`(\hat{X}_k)` given by

.. math::

    \hat{X}_s=\sum_{r=0}^N\exp(-2\pi i\cdot t_r f_s)X_r.

Note that the NDFT reduces the the DFT in the case :math:`t_k=k` and :math:`f_k=k/N`.  Nyquist's theorem does not constrain the choice of frequencies so much in this case, since the Nyquist frequency is :math:`1/2d` where :math:`d>0` is the "highest common factor" of the :math:`t_k`, that is, the largest value that each :math:`t_k` is an integer multiple of.

The NDFT can be evaluated directly in :math:`\mathcal{O}(mn)` time (:meth:`ndft.exe_ndft`), and there are approximate algorithms (called NuFFTs) which use interpolation and the FFT to calculate an approximation in :math:`\mathcal{O}(m\log m)` time (:meth:`ndft.exe_nfft_py`). In this case, the frequencies :math:`f_k` must be uniformly spaced, and generally :math:`m` should be much larger than :math:`n`. Alternatively, if the times :math:`t_k` are all integer multiples of some factor :math:`d`, then the NDFT can be embedded in a large DFT with times :math:`\tilde{t}_k=kd` and missing values of :math:`X(\tilde{t}_k)` set to zero (:meth:`ndft.exe_ndft_fft`). This is often the case in practice, since the finite time-resolution of measuring devices serves as a suitable common factor.

Suppose now that the times :math:`t_k` have been embedded in a regular sequence :math:`\tilde{t}_k=kd`, as above. The associated DFT will have a size of approximately :math:`(t_N-t_1)/d`, so if :math:`d` is relatively large then evaluation is very fast due to the FFT. Since the sampling is nonuniform, some values of :math:`X(\tilde{t}_k)` will be missing; if the pattern of missing values is periodic, a further increase in efficiency can be made by exploiting the way in which the DFT factors. More precisely, let :math:`N=q\times L`, with :math:`q` sample times per period :math:`p`. Then the sample times can be written :math:`t_{aq+b}=(ap+T_b)d`, where :math:`0\leq b<q`. Setting the frequencies to :math:`f_k=k/(Nd)`, the NDFT of :math:`(X_k)` can be written

.. math::

    \hat{X}_s=\sum_{a=0}^L\exp\left(-\frac{2\pi i}{N}\cdot aps\right)\sum_{b=0}^q\exp\left(-\frac{2\pi i}{N}\cdot T_bs\right)X_{aq+b}.

For :math:`q\ll m`, the above sum can be evaluated in :math:`\mathcal{O}(qm\log m)` time (:meth:`ndft.exe_nfft_per`). For comparison, computing the full associated DFT takes :math:`\mathcal{O}(pm\log m)` time (when :math:`p\ll m`), so this approach is especially advantageous for sparse nonuniform periodic sampling (with :math:`q\ll p`).

Power Spectral Density
----------------------
The **power spectral density** (PSD) :math:`S_{XX}` of a wide-sense stationary signal :math:`X` measures how the signal's power is distributed over frequency (wide-sense stationarity means that the mean and variance of the signal remain constant). For a signal :math:`X(t)` sampled at :math:`N` integral times, the PSD at frequency :math:`k/N` is estimated by

.. math::

    S_{XX}\left(\frac{k}{N}\right)=\frac{\left|\hat{X}\left(k/N\right)\right|}{N}.

If :math:`X` is instead sampled nonuniformly at times :math:`t_i`, the above expression can be generalised to use the NDFT instead (:meth:`ndft.calc_psd`). Other generalisations (such as the Lomb-Scargle periodogram) exist, but these generally take real data only.

The **spectral window function** :math:`S_{1,1}` measures how regularly the signal is sampled modulo each frequency (:meth:`ndft.spec_win`); here, :math:`1` is the constant function sampled at the same times :math:`t_i` as the signal. Periodicity in the sampling can cause aliasing and phantom peaks in the PSD estimates, and this effect can be reduced by deconvolution with :math:`S_{1,1}` (:meth:`ndft.calc_deconvolved_psd`). However, this operation is ill-conditioned, and accurate estimates can only be obtained if the ACF estimation (see next section) is accurate at all lags used.

Autocorrelation
---------------
The **autocorrelation function** (ACF) :math:`R_{XX}(\tau)` of a signal :math:`X` is defined to be the cross-correlation of :math:`X` with a lagged copy of itself. In the case of nonuniform sampling at times :math:`t_i`, some summands will be missing due to missing data:

.. math::

    R_{XX}(\tau)=\sum_{k:\ X(t_k-\tau)\text{ exists}}X(t_k)\overline{X(t_k-\tau)}.

By the Weiner-Khinchin theorem, the ACF is also the Fourier transform of the PSD, and so it can be estimated by applying the FFT to a PSD estimate. The ACF can be normalised by the variance of the signal; assuming wide-sense stationarity, the variance of a signal at lag :math:`\tau` is proportional to the number of gaps of length :math:`\tau` in the sampling pattern of the signal, and so the normalised ACF :math:`\overline{R}_{XX}(\tau)` can be estimated by

.. math::

    \overline{R}_{XX}(\tau)=\frac{R_{XX}(\tau)}{R_{XX}(0)\cdot R_{1,1}(\tau)}.

Here, :math:`R_{1,1}` is the FFT of the spectral window function :math:`S_{1,1}` (:meth:`ndft.lag_strength`), and :math:`R_{XX}(0)` normalises :math:`\overline{R}_{XX}(0)` to a value of :math:`1`.

The direct cross-correlation calculation is implemented in :meth:`util.direct_acf`, whilst the spectral (PSD) method, which is in theory faster due to the FFT, is implemented in :meth:`ndft.calc_ac`. Note that, by default, the mean of the signal is not removed.

ARMA Process
------------
**ARMA processes** are a family of WSS random processes with known PSD and ACF; this makes them useful for examples and testing. An ARMA process :math:`(X_n)` with parameters :math:`(\phi_j)`, :math:`(\theta_k)` and :math:`\sigma^2` can be generated recursively by

.. math::

    X_n = \sum_{j=1}^p\phi_j X_{n-j}-\sum_{k=1}^q\theta_k W_{n-k},

where :math:`(W_n)` is white Gaussian noise with variance :math:`\sigma^2`. In the implementation in :meth:`arma.arma`, the process :math:`(W_n)` is in fact complex white Gaussian noise.

This process is only stationary if the (complex) roots of the polynomial :math:`1-\sum_j\phi_j x^j` all lie outside the unit circle.

The PSD of :math:`(X_n)` (:meth:`arma.psd_exact`) is given by

.. math::
    S_{XX}(f)=\sigma^2\left|\frac{1-\hat{\phi}(f)}{1-\hat{\theta}(f)}\right|^2,

where :math:`\hat{\phi}` and :math:`\hat{\theta}` are the NDFTs of the vectors of parameters :math:`\phi` and :math:`\theta`.

If :math:`\phi` and :math:`\theta` are real-valued, the normalised ACF of :math:`(X_n)` (:meth:`arma.acf_exact`) at integer lags is real, and is given by the solution to the difference equation

.. math::
    R_{XX}(\tau)=\sum_{j=1}^p\phi_j R_{XX}(f-j)\text{ for }\tau\geq p,\tau>q,

with initial conditions

.. math::
    R_{XX}(\tau)=\sum_{j=1}^p\phi_j R_{XX}(f-j)+\sigma^2\sum_{k=\tau}^q\theta_k\psi_{k-\tau}\text{ for }\tau<\max(p,q+1),

where the :math:`\psi_k` are the Taylor coefficients of the rational function

.. math::
    \frac{1-\sum_k\theta_k x^k}{1-\sum_j\phi_j x^j}\equiv\sum_{r=0}^\infty\psi_r x^r.

References
----------
Bogacka, B. 2008. MTH6139 Time Series Lecture Notes. Queen Mary University of London. http://www.maths.qmul.ac.uk/~bb/TimeSeries/MAS328.html (accessed 2021-09-22).

Keiner, J., Kunis, S., and Potts, D. 2009. Using NFFT 3 — a software library for various non-equispaced fast Fourier transforms. ACM Trans. Math. Softw. 36, 4, Article 19 (August 2009), 30 pages. DOI: 10.1145/1555386.1555388. http://doi.acm.org/10.1145/1555386.1555388.

Percival, D., and Walden, A. 2020. Spectral Analysis for Univariate Time Series (Cambridge Series in Statistical and Probabilistic Mathematics). Cambridge: Cambridge University Press. DOI:10.1017/9781139235723

Van Loan, C. 1992. Computational Frameworks for the Fast Fourier Transform (Frontiers in Applied Mathematics). Philadelphia, PA, USA: Society for Industrial and Applied Mathematics.

Vityazev, V. V. 1996. Time series analysis of unequally spaced data: Intercomparison between the Schuster periodogram and the LS-spectra. Astronomical and Astrophysical Transactions, 11:2, 139-158. DOI: 10.1080/10556799608205461. https://www.tandfonline.com/doi/abs/10.1080/10556799608205461.

Methods
=======
.. automodule:: ndft
   :members:

.. automodule:: arma
   :members:
   
.. automodule:: util
   :members:

.. automodule:: periodic
    :members:

Indices
=======

* :ref:`genindex`
* :ref:`modindex`
* :ref:`search`